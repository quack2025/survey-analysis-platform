/**
 * Utilidades para exportar resultados en diferentes formatos
 */

import { ClassifiedAnswer } from '@/types';

export interface RespondentLevelData {
  respondentId: string;
  question: string;
  answer: string;
  nets: string[];
  codes: string[];
  sentiments: string[];
}

export interface PivotData {
  respondentId: string;
  [key: string]: string | number; // Dynamic columns for each code
}

/**
 * Formato 1: Detallado a nivel de respondente
 * Una fila por cada combinación respondente-código
 */
export function exportDetailedCSV(
  classifiedAnswers: ClassifiedAnswer[],
  questionText: string,
  respondentIds: string[]
): string {
  const rows: string[] = [
    'RespondentID,Question,Answer,Net,Code,Sentiment'
  ];

  classifiedAnswers.forEach((ca, idx) => {
    const respondentId = respondentIds[idx] || `resp_${idx + 1}`;
    const answer = ca.answer.replace(/"/g, '""'); // Escape quotes

    if (ca.nets && ca.nets.length > 0) {
      ca.nets.forEach((net: any) => {
        if (net.codes && net.codes.length > 0) {
          net.codes.forEach((code: any) => {
            rows.push(
              `"${respondentId}","${questionText}","${answer}","${net.net}","${code.code}","${code.sentiment}"`
            );
          });
        }
      });
    } else {
      // No classification
      rows.push(
        `"${respondentId}","${questionText}","${answer}","Uncategorized","Uncategorized","Neutral"`
      );
    }
  });

  return rows.join('\n');
}

/**
 * Formato 2: Pivot - Una fila por respondente, columnas por código (0/1)
 * Perfecto para análisis estadístico en SPSS/R
 */
export function exportPivotCSV(
  classifiedAnswers: ClassifiedAnswer[],
  allCodes: string[],
  respondentIds: string[]
): string {
  // Header
  const header = ['RespondentID', 'Answer', ...allCodes].join(',');
  const rows: string[] = [header];

  classifiedAnswers.forEach((ca, idx) => {
    const respondentId = respondentIds[idx] || `resp_${idx + 1}`;
    const answer = ca.answer.replace(/"/g, '""');

    // Get codes for this respondent
    const respondentCodes = new Set<string>();
    if (ca.nets) {
      ca.nets.forEach((net: any) => {
        if (net.codes) {
          net.codes.forEach((code: any) => {
            respondentCodes.add(code.code);
          });
        }
      });
    }

    // Create row with 0/1 for each code
    const codeValues = allCodes.map(code =>
      respondentCodes.has(code) ? '1' : '0'
    );

    rows.push(
      `"${respondentId}","${answer}",${codeValues.join(',')}`
    );
  });

  return rows.join('\n');
}

/**
 * Formato 3: Agregado por Net
 * Una fila por respondente con todos los nets concatenados
 */
export function exportNetSummaryCSV(
  classifiedAnswers: ClassifiedAnswer[],
  respondentIds: string[]
): string {
  const rows: string[] = [
    'RespondentID,Answer,Nets,Codes,Sentiments,PositiveCount,NeutralCount,NegativeCount'
  ];

  classifiedAnswers.forEach((ca, idx) => {
    const respondentId = respondentIds[idx] || `resp_${idx + 1}`;
    const answer = ca.answer.replace(/"/g, '""');

    const nets: string[] = [];
    const codes: string[] = [];
    const sentiments: string[] = [];
    let positiveCount = 0;
    let neutralCount = 0;
    let negativeCount = 0;

    if (ca.nets) {
      ca.nets.forEach((net: any) => {
        if (net.codes) {
          net.codes.forEach((code: any) => {
            nets.push(net.net);
            codes.push(code.code);
            sentiments.push(code.sentiment);

            if (code.sentiment === 'Positive') positiveCount++;
            else if (code.sentiment === 'Neutral') neutralCount++;
            else if (code.sentiment === 'Negative') negativeCount++;
          });
        }
      });
    }

    rows.push(
      `"${respondentId}","${answer}","${nets.join(' | ')}","${codes.join(' | ')}","${sentiments.join(' | ')}",${positiveCount},${neutralCount},${negativeCount}`
    );
  });

  return rows.join('\n');
}

/**
 * Formato 4: SPSS Syntax Generator
 * Genera sintaxis SPSS para crear variables categóricas
 */
export function generateSPSSSyntax(
  allCodes: string[],
  questionText: string
): string {
  const varPrefix = 'Q1'; // Cambiar según necesidad

  let syntax = `* SPSS Syntax for: ${questionText}\n`;
  syntax += `* Generated by Survey Analysis Platform\n\n`;

  // Variable labels
  syntax += `VARIABLE LABELS\n`;
  allCodes.forEach((code, idx) => {
    const varName = `${varPrefix}_${idx + 1}`;
    syntax += `  ${varName} "${code}"\n`;
  });
  syntax += `.\n\n`;

  // Value labels
  syntax += `VALUE LABELS\n`;
  allCodes.forEach((code, idx) => {
    const varName = `${varPrefix}_${idx + 1}`;
    syntax += `  ${varName} 0 "No mencionado" 1 "Mencionado"\n`;
  });
  syntax += `.\n\n`;

  // Frequencies
  syntax += `FREQUENCIES VARIABLES=`;
  allCodes.forEach((code, idx) => {
    syntax += `${varPrefix}_${idx + 1} `;
  });
  syntax += `.\n`;

  return syntax;
}

/**
 * Formato 5: Excel con múltiples hojas
 */
export function prepareExcelData(
  classifiedAnswers: ClassifiedAnswer[],
  nets: any[],
  questionText: string,
  respondentIds: string[]
) {
  return {
    summary: {
      question: questionText,
      totalResponses: classifiedAnswers.length,
      netsCount: nets.length,
      timestamp: new Date().toISOString(),
    },
    detailedData: classifiedAnswers.map((ca, idx) => ({
      respondentId: respondentIds[idx] || `resp_${idx + 1}`,
      answer: ca.answer,
      nets: ca.nets?.map((n: any) => n.net).join(' | ') || '',
      codes: ca.nets?.flatMap((n: any) => n.codes?.map((c: any) => c.code) || []).join(' | ') || '',
      sentiments: ca.nets?.flatMap((n: any) => n.codes?.map((c: any) => c.sentiment) || []).join(' | ') || '',
    })),
    netsSummary: nets.map(net => ({
      net: net.net,
      codesCount: net.codes?.length || 0,
      codes: net.codes?.map((c: any) => c.code).join(', ') || '',
    })),
  };
}

/**
 * Crear nombre de archivo sanitizado
 */
export function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-z0-9]/gi, '_')
    .substring(0, 50)
    .toLowerCase();
}

/**
 * Descargar archivo
 */
export function downloadFile(content: string, filename: string, mimeType: string = 'text/csv') {
  const blob = new Blob([content], { type: mimeType });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);
}
